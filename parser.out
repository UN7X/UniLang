Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    OR

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     program -> statement_list NEWLINE
Rule 3     statement_list -> statement_list NEWLINE statement
Rule 4     statement_list -> statement
Rule 5     statement -> assignment
Rule 6     statement -> print_statement
Rule 7     statement -> if_statement
Rule 8     statement -> while_statement
Rule 9     statement -> function_def
Rule 10    statement -> for_loop
Rule 11    statement -> return_statement
Rule 12    statement -> wait_statement
Rule 13    statement -> block
Rule 14    statement -> expression_statement
Rule 15    expression_statement -> expression
Rule 16    expression -> expression INCREMENT
Rule 17    expression -> expression DECREMENT
Rule 18    expression -> IDENTIFIER PLUS_EQUALS expression
Rule 19    expression -> IDENTIFIER MINUS_EQUALS expression
Rule 20    assignment -> IDENTIFIER EQUALS expression
Rule 21    print_statement -> PRINT LPAREN expression RPAREN
Rule 22    if_statement -> IF expression block
Rule 23    if_statement -> IF expression block ELSE block
Rule 24    for_loop -> FOR IDENTIFIER IN iterable block
Rule 25    iterable -> expression
Rule 26    iterable -> RANGE LPAREN expression COMMA expression RPAREN
Rule 27    while_statement -> WHILE expression block
Rule 28    function_def -> DEFINE IDENTIFIER LPAREN RPAREN block
Rule 29    function_def -> DEFINE IDENTIFIER LPAREN param_list RPAREN block
Rule 30    param_list -> IDENTIFIER
Rule 31    param_list -> param_list COMMA IDENTIFIER
Rule 32    param_list -> empty
Rule 33    statement -> IMPORT IDENTIFIER
Rule 34    return_statement -> RESULT expression
Rule 35    expression -> logic_expr
Rule 36    expression -> fstring
Rule 37    expression -> function_call
Rule 38    fstring -> F_QUOTE fstring_content QUOTE
Rule 39    fstring_content -> fstring_content fstring_part
Rule 40    fstring_content -> fstring_part
Rule 41    fstring_part -> STRING_CONTENT
Rule 42    fstring_part -> LBRACE expression RBRACE
Rule 43    logic_expr -> logic_expr OR_OP logic_term
Rule 44    logic_expr -> logic_term
Rule 45    logic_term -> logic_term AND_OP equality_expr
Rule 46    logic_term -> equality_expr
Rule 47    equality_expr -> equality_expr EQ relational_expr
Rule 48    equality_expr -> equality_expr NEQ relational_expr
Rule 49    equality_expr -> relational_expr
Rule 50    relational_expr -> relational_expr LT additive_expr
Rule 51    relational_expr -> relational_expr LE additive_expr
Rule 52    relational_expr -> relational_expr GT additive_expr
Rule 53    relational_expr -> relational_expr GE additive_expr
Rule 54    relational_expr -> additive_expr
Rule 55    additive_expr -> additive_expr PLUS term
Rule 56    additive_expr -> additive_expr MINUS term
Rule 57    additive_expr -> term
Rule 58    term -> term TIMES factor
Rule 59    term -> term DIVIDE factor
Rule 60    term -> term MOD factor
Rule 61    term -> factor
Rule 62    factor -> PLUS factor
Rule 63    factor -> MINUS factor
Rule 64    factor -> NOT factor
Rule 65    factor -> primary
Rule 66    primary -> atom
Rule 67    primary -> function_call
Rule 68    atom -> IDENTIFIER
Rule 69    atom -> NUMBER
Rule 70    atom -> STRING
Rule 71    atom -> TRUE
Rule 72    atom -> FALSE
Rule 73    atom -> LPAREN expression RPAREN
Rule 74    member_access_chain -> member_access_chain member_access
Rule 75    member_access_chain -> empty
Rule 76    member_access -> DOT IDENTIFIER
Rule 77    member_access -> DOT IDENTIFIER LPAREN arg_list RPAREN
Rule 78    member_access -> DOT IDENTIFIER LPAREN RPAREN
Rule 79    wait_statement -> WAIT expression
Rule 80    function_call -> IDENTIFIER LPAREN arg_list RPAREN
Rule 81    function_call -> IDENTIFIER LPAREN RPAREN
Rule 82    function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN
Rule 83    function_call -> primary DOT IDENTIFIER LPAREN RPAREN
Rule 84    arg_list -> expression
Rule 85    arg_list -> arg_list COMMA expression
Rule 86    arg_list -> empty
Rule 87    block -> LBRACE RBRACE
Rule 88    block -> LBRACE statement_list RBRACE
Rule 89    empty -> <empty>

Terminals, with rules where they appear

AND                  : 
AND_OP               : 45
COMMA                : 26 31 85
DECREMENT            : 17
DEFINE               : 28 29
DIVIDE               : 59
DOT                  : 76 77 78 82 83
ELSE                 : 23
EQ                   : 47
EQUALS               : 20
FALSE                : 72
FOR                  : 24
F_QUOTE              : 38
GE                   : 53
GT                   : 52
IDENTIFIER           : 18 19 20 24 28 29 30 31 33 68 76 77 78 80 81 82 83
IF                   : 22 23
IMPORT               : 33
IN                   : 24
INCREMENT            : 16
LBRACE               : 42 87 88
LE                   : 51
LPAREN               : 21 26 28 29 73 77 78 80 81 82 83
LT                   : 50
MINUS                : 56 63
MINUS_EQUALS         : 19
MOD                  : 60
NEQ                  : 48
NEWLINE              : 2 3
NOT                  : 64
NUMBER               : 69
OR                   : 
OR_OP                : 43
PLUS                 : 55 62
PLUS_EQUALS          : 18
PRINT                : 21
QUOTE                : 38
RANGE                : 26
RBRACE               : 42 87 88
RESULT               : 34
RPAREN               : 21 26 28 29 73 77 78 80 81 82 83
STRING               : 70
STRING_CONTENT       : 41
TIMES                : 58
TRUE                 : 71
WAIT                 : 79
WHILE                : 27
error                : 

Nonterminals, with rules where they appear

additive_expr        : 50 51 52 53 54 55 56
arg_list             : 77 80 82 85
assignment           : 5
atom                 : 66
block                : 13 22 23 23 24 27 28 29
empty                : 32 75 86
equality_expr        : 45 46 47 48
expression           : 15 16 17 18 19 20 21 22 23 25 26 26 27 34 42 73 79 84 85
expression_statement : 14
factor               : 58 59 60 61 62 63 64
for_loop             : 10
fstring              : 36
fstring_content      : 38 39
fstring_part         : 39 40
function_call        : 37 67
function_def         : 9
if_statement         : 7
iterable             : 24
logic_expr           : 35 43
logic_term           : 43 44 45
member_access        : 74
member_access_chain  : 74
param_list           : 29 31
primary              : 65 82 83
print_statement      : 6
program              : 0
relational_expr      : 47 48 49 50 51 52 53
return_statement     : 11
statement            : 3 4
statement_list       : 1 2 3 88
term                 : 55 56 57 58 59 60
wait_statement       : 12
while_statement      : 8

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) program -> . statement_list NEWLINE
    (3) statement_list -> . statement_list NEWLINE statement
    (4) statement_list -> . statement
    (5) statement -> . assignment
    (6) statement -> . print_statement
    (7) statement -> . if_statement
    (8) statement -> . while_statement
    (9) statement -> . function_def
    (10) statement -> . for_loop
    (11) statement -> . return_statement
    (12) statement -> . wait_statement
    (13) statement -> . block
    (14) statement -> . expression_statement
    (33) statement -> . IMPORT IDENTIFIER
    (20) assignment -> . IDENTIFIER EQUALS expression
    (21) print_statement -> . PRINT LPAREN expression RPAREN
    (22) if_statement -> . IF expression block
    (23) if_statement -> . IF expression block ELSE block
    (27) while_statement -> . WHILE expression block
    (28) function_def -> . DEFINE IDENTIFIER LPAREN RPAREN block
    (29) function_def -> . DEFINE IDENTIFIER LPAREN param_list RPAREN block
    (24) for_loop -> . FOR IDENTIFIER IN iterable block
    (34) return_statement -> . RESULT expression
    (79) wait_statement -> . WAIT expression
    (87) block -> . LBRACE RBRACE
    (88) block -> . LBRACE statement_list RBRACE
    (15) expression_statement -> . expression
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IMPORT          shift and go to state 14
    IDENTIFIER      shift and go to state 15
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    WHILE           shift and go to state 20
    DEFINE          shift and go to state 21
    FOR             shift and go to state 22
    RESULT          shift and go to state 23
    WAIT            shift and go to state 24
    LBRACE          shift and go to state 25
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    print_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    function_def                   shift and go to state 8
    for_loop                       shift and go to state 9
    return_statement               shift and go to state 10
    wait_statement                 shift and go to state 11
    block                          shift and go to state 12
    expression_statement           shift and go to state 13
    expression                     shift and go to state 16
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (2) program -> statement_list . NEWLINE
    (3) statement_list -> statement_list . NEWLINE statement

    $end            reduce using rule 1 (program -> statement_list .)
    NEWLINE         shift and go to state 45


state 3

    (4) statement_list -> statement .

    NEWLINE         reduce using rule 4 (statement_list -> statement .)
    $end            reduce using rule 4 (statement_list -> statement .)
    RBRACE          reduce using rule 4 (statement_list -> statement .)


state 4

    (5) statement -> assignment .

    NEWLINE         reduce using rule 5 (statement -> assignment .)
    $end            reduce using rule 5 (statement -> assignment .)
    RBRACE          reduce using rule 5 (statement -> assignment .)


state 5

    (6) statement -> print_statement .

    NEWLINE         reduce using rule 6 (statement -> print_statement .)
    $end            reduce using rule 6 (statement -> print_statement .)
    RBRACE          reduce using rule 6 (statement -> print_statement .)


state 6

    (7) statement -> if_statement .

    NEWLINE         reduce using rule 7 (statement -> if_statement .)
    $end            reduce using rule 7 (statement -> if_statement .)
    RBRACE          reduce using rule 7 (statement -> if_statement .)


state 7

    (8) statement -> while_statement .

    NEWLINE         reduce using rule 8 (statement -> while_statement .)
    $end            reduce using rule 8 (statement -> while_statement .)
    RBRACE          reduce using rule 8 (statement -> while_statement .)


state 8

    (9) statement -> function_def .

    NEWLINE         reduce using rule 9 (statement -> function_def .)
    $end            reduce using rule 9 (statement -> function_def .)
    RBRACE          reduce using rule 9 (statement -> function_def .)


state 9

    (10) statement -> for_loop .

    NEWLINE         reduce using rule 10 (statement -> for_loop .)
    $end            reduce using rule 10 (statement -> for_loop .)
    RBRACE          reduce using rule 10 (statement -> for_loop .)


state 10

    (11) statement -> return_statement .

    NEWLINE         reduce using rule 11 (statement -> return_statement .)
    $end            reduce using rule 11 (statement -> return_statement .)
    RBRACE          reduce using rule 11 (statement -> return_statement .)


state 11

    (12) statement -> wait_statement .

    NEWLINE         reduce using rule 12 (statement -> wait_statement .)
    $end            reduce using rule 12 (statement -> wait_statement .)
    RBRACE          reduce using rule 12 (statement -> wait_statement .)


state 12

    (13) statement -> block .

    NEWLINE         reduce using rule 13 (statement -> block .)
    $end            reduce using rule 13 (statement -> block .)
    RBRACE          reduce using rule 13 (statement -> block .)


state 13

    (14) statement -> expression_statement .

    NEWLINE         reduce using rule 14 (statement -> expression_statement .)
    $end            reduce using rule 14 (statement -> expression_statement .)
    RBRACE          reduce using rule 14 (statement -> expression_statement .)


state 14

    (33) statement -> IMPORT . IDENTIFIER

    IDENTIFIER      shift and go to state 46


state 15

    (20) assignment -> IDENTIFIER . EQUALS expression
    (18) expression -> IDENTIFIER . PLUS_EQUALS expression
    (19) expression -> IDENTIFIER . MINUS_EQUALS expression
    (80) function_call -> IDENTIFIER . LPAREN arg_list RPAREN
    (81) function_call -> IDENTIFIER . LPAREN RPAREN
    (68) atom -> IDENTIFIER .

    EQUALS          shift and go to state 47
    PLUS_EQUALS     shift and go to state 48
    MINUS_EQUALS    shift and go to state 49
    LPAREN          shift and go to state 50
    DOT             reduce using rule 68 (atom -> IDENTIFIER .)
    TIMES           reduce using rule 68 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 68 (atom -> IDENTIFIER .)
    MOD             reduce using rule 68 (atom -> IDENTIFIER .)
    PLUS            reduce using rule 68 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 68 (atom -> IDENTIFIER .)
    LT              reduce using rule 68 (atom -> IDENTIFIER .)
    LE              reduce using rule 68 (atom -> IDENTIFIER .)
    GT              reduce using rule 68 (atom -> IDENTIFIER .)
    GE              reduce using rule 68 (atom -> IDENTIFIER .)
    EQ              reduce using rule 68 (atom -> IDENTIFIER .)
    NEQ             reduce using rule 68 (atom -> IDENTIFIER .)
    AND_OP          reduce using rule 68 (atom -> IDENTIFIER .)
    OR_OP           reduce using rule 68 (atom -> IDENTIFIER .)
    INCREMENT       reduce using rule 68 (atom -> IDENTIFIER .)
    DECREMENT       reduce using rule 68 (atom -> IDENTIFIER .)
    NEWLINE         reduce using rule 68 (atom -> IDENTIFIER .)
    $end            reduce using rule 68 (atom -> IDENTIFIER .)
    RBRACE          reduce using rule 68 (atom -> IDENTIFIER .)


state 16

    (15) expression_statement -> expression .
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    NEWLINE         reduce using rule 15 (expression_statement -> expression .)
    $end            reduce using rule 15 (expression_statement -> expression .)
    RBRACE          reduce using rule 15 (expression_statement -> expression .)
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 17

    (21) print_statement -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 53


state 18

    (73) atom -> LPAREN . expression RPAREN
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 54
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 19

    (22) if_statement -> IF . expression block
    (23) if_statement -> IF . expression block ELSE block
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 56
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 20

    (27) while_statement -> WHILE . expression block
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 57
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 21

    (28) function_def -> DEFINE . IDENTIFIER LPAREN RPAREN block
    (29) function_def -> DEFINE . IDENTIFIER LPAREN param_list RPAREN block

    IDENTIFIER      shift and go to state 58


state 22

    (24) for_loop -> FOR . IDENTIFIER IN iterable block

    IDENTIFIER      shift and go to state 59


state 23

    (34) return_statement -> RESULT . expression
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 60
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 24

    (79) wait_statement -> WAIT . expression
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 61
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 25

    (87) block -> LBRACE . RBRACE
    (88) block -> LBRACE . statement_list RBRACE
    (3) statement_list -> . statement_list NEWLINE statement
    (4) statement_list -> . statement
    (5) statement -> . assignment
    (6) statement -> . print_statement
    (7) statement -> . if_statement
    (8) statement -> . while_statement
    (9) statement -> . function_def
    (10) statement -> . for_loop
    (11) statement -> . return_statement
    (12) statement -> . wait_statement
    (13) statement -> . block
    (14) statement -> . expression_statement
    (33) statement -> . IMPORT IDENTIFIER
    (20) assignment -> . IDENTIFIER EQUALS expression
    (21) print_statement -> . PRINT LPAREN expression RPAREN
    (22) if_statement -> . IF expression block
    (23) if_statement -> . IF expression block ELSE block
    (27) while_statement -> . WHILE expression block
    (28) function_def -> . DEFINE IDENTIFIER LPAREN RPAREN block
    (29) function_def -> . DEFINE IDENTIFIER LPAREN param_list RPAREN block
    (24) for_loop -> . FOR IDENTIFIER IN iterable block
    (34) return_statement -> . RESULT expression
    (79) wait_statement -> . WAIT expression
    (87) block -> . LBRACE RBRACE
    (88) block -> . LBRACE statement_list RBRACE
    (15) expression_statement -> . expression
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    RBRACE          shift and go to state 62
    IMPORT          shift and go to state 14
    IDENTIFIER      shift and go to state 15
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    WHILE           shift and go to state 20
    DEFINE          shift and go to state 21
    FOR             shift and go to state 22
    RESULT          shift and go to state 23
    WAIT            shift and go to state 24
    LBRACE          shift and go to state 25
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    statement_list                 shift and go to state 63
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    print_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    function_def                   shift and go to state 8
    for_loop                       shift and go to state 9
    return_statement               shift and go to state 10
    wait_statement                 shift and go to state 11
    block                          shift and go to state 12
    expression_statement           shift and go to state 13
    expression                     shift and go to state 16
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 26

    (35) expression -> logic_expr .
    (43) logic_expr -> logic_expr . OR_OP logic_term

    INCREMENT       reduce using rule 35 (expression -> logic_expr .)
    DECREMENT       reduce using rule 35 (expression -> logic_expr .)
    NEWLINE         reduce using rule 35 (expression -> logic_expr .)
    $end            reduce using rule 35 (expression -> logic_expr .)
    RPAREN          reduce using rule 35 (expression -> logic_expr .)
    LBRACE          reduce using rule 35 (expression -> logic_expr .)
    RBRACE          reduce using rule 35 (expression -> logic_expr .)
    COMMA           reduce using rule 35 (expression -> logic_expr .)
    OR_OP           shift and go to state 64


state 27

    (36) expression -> fstring .

    INCREMENT       reduce using rule 36 (expression -> fstring .)
    DECREMENT       reduce using rule 36 (expression -> fstring .)
    NEWLINE         reduce using rule 36 (expression -> fstring .)
    $end            reduce using rule 36 (expression -> fstring .)
    RPAREN          reduce using rule 36 (expression -> fstring .)
    LBRACE          reduce using rule 36 (expression -> fstring .)
    RBRACE          reduce using rule 36 (expression -> fstring .)
    COMMA           reduce using rule 36 (expression -> fstring .)


state 28

    (37) expression -> function_call .
    (67) primary -> function_call .

  ! reduce/reduce conflict for INCREMENT resolved using rule 37 (expression -> function_call .)
  ! reduce/reduce conflict for DECREMENT resolved using rule 37 (expression -> function_call .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 37 (expression -> function_call .)
  ! reduce/reduce conflict for $end resolved using rule 37 (expression -> function_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 37 (expression -> function_call .)
  ! reduce/reduce conflict for LBRACE resolved using rule 37 (expression -> function_call .)
  ! reduce/reduce conflict for RBRACE resolved using rule 37 (expression -> function_call .)
  ! reduce/reduce conflict for COMMA resolved using rule 37 (expression -> function_call .)
    INCREMENT       reduce using rule 37 (expression -> function_call .)
    DECREMENT       reduce using rule 37 (expression -> function_call .)
    NEWLINE         reduce using rule 37 (expression -> function_call .)
    $end            reduce using rule 37 (expression -> function_call .)
    RPAREN          reduce using rule 37 (expression -> function_call .)
    LBRACE          reduce using rule 37 (expression -> function_call .)
    RBRACE          reduce using rule 37 (expression -> function_call .)
    COMMA           reduce using rule 37 (expression -> function_call .)
    DOT             reduce using rule 67 (primary -> function_call .)
    TIMES           reduce using rule 67 (primary -> function_call .)
    DIVIDE          reduce using rule 67 (primary -> function_call .)
    MOD             reduce using rule 67 (primary -> function_call .)
    PLUS            reduce using rule 67 (primary -> function_call .)
    MINUS           reduce using rule 67 (primary -> function_call .)
    LT              reduce using rule 67 (primary -> function_call .)
    LE              reduce using rule 67 (primary -> function_call .)
    GT              reduce using rule 67 (primary -> function_call .)
    GE              reduce using rule 67 (primary -> function_call .)
    EQ              reduce using rule 67 (primary -> function_call .)
    NEQ             reduce using rule 67 (primary -> function_call .)
    AND_OP          reduce using rule 67 (primary -> function_call .)
    OR_OP           reduce using rule 67 (primary -> function_call .)

  ! INCREMENT       [ reduce using rule 67 (primary -> function_call .) ]
  ! DECREMENT       [ reduce using rule 67 (primary -> function_call .) ]
  ! NEWLINE         [ reduce using rule 67 (primary -> function_call .) ]
  ! $end            [ reduce using rule 67 (primary -> function_call .) ]
  ! RPAREN          [ reduce using rule 67 (primary -> function_call .) ]
  ! LBRACE          [ reduce using rule 67 (primary -> function_call .) ]
  ! RBRACE          [ reduce using rule 67 (primary -> function_call .) ]
  ! COMMA           [ reduce using rule 67 (primary -> function_call .) ]


state 29

    (44) logic_expr -> logic_term .
    (45) logic_term -> logic_term . AND_OP equality_expr

    OR_OP           reduce using rule 44 (logic_expr -> logic_term .)
    INCREMENT       reduce using rule 44 (logic_expr -> logic_term .)
    DECREMENT       reduce using rule 44 (logic_expr -> logic_term .)
    NEWLINE         reduce using rule 44 (logic_expr -> logic_term .)
    $end            reduce using rule 44 (logic_expr -> logic_term .)
    RPAREN          reduce using rule 44 (logic_expr -> logic_term .)
    LBRACE          reduce using rule 44 (logic_expr -> logic_term .)
    RBRACE          reduce using rule 44 (logic_expr -> logic_term .)
    COMMA           reduce using rule 44 (logic_expr -> logic_term .)
    AND_OP          shift and go to state 65


state 30

    (38) fstring -> F_QUOTE . fstring_content QUOTE
    (39) fstring_content -> . fstring_content fstring_part
    (40) fstring_content -> . fstring_part
    (41) fstring_part -> . STRING_CONTENT
    (42) fstring_part -> . LBRACE expression RBRACE

    STRING_CONTENT  shift and go to state 68
    LBRACE          shift and go to state 69

    fstring_content                shift and go to state 66
    fstring_part                   shift and go to state 67

state 31

    (82) function_call -> primary . DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> primary . DOT IDENTIFIER LPAREN RPAREN
    (65) factor -> primary .

    DOT             shift and go to state 70
    TIMES           reduce using rule 65 (factor -> primary .)
    DIVIDE          reduce using rule 65 (factor -> primary .)
    MOD             reduce using rule 65 (factor -> primary .)
    PLUS            reduce using rule 65 (factor -> primary .)
    MINUS           reduce using rule 65 (factor -> primary .)
    LT              reduce using rule 65 (factor -> primary .)
    LE              reduce using rule 65 (factor -> primary .)
    GT              reduce using rule 65 (factor -> primary .)
    GE              reduce using rule 65 (factor -> primary .)
    EQ              reduce using rule 65 (factor -> primary .)
    NEQ             reduce using rule 65 (factor -> primary .)
    AND_OP          reduce using rule 65 (factor -> primary .)
    OR_OP           reduce using rule 65 (factor -> primary .)
    INCREMENT       reduce using rule 65 (factor -> primary .)
    DECREMENT       reduce using rule 65 (factor -> primary .)
    NEWLINE         reduce using rule 65 (factor -> primary .)
    $end            reduce using rule 65 (factor -> primary .)
    RPAREN          reduce using rule 65 (factor -> primary .)
    LBRACE          reduce using rule 65 (factor -> primary .)
    RBRACE          reduce using rule 65 (factor -> primary .)
    COMMA           reduce using rule 65 (factor -> primary .)


state 32

    (46) logic_term -> equality_expr .
    (47) equality_expr -> equality_expr . EQ relational_expr
    (48) equality_expr -> equality_expr . NEQ relational_expr

    AND_OP          reduce using rule 46 (logic_term -> equality_expr .)
    OR_OP           reduce using rule 46 (logic_term -> equality_expr .)
    INCREMENT       reduce using rule 46 (logic_term -> equality_expr .)
    DECREMENT       reduce using rule 46 (logic_term -> equality_expr .)
    NEWLINE         reduce using rule 46 (logic_term -> equality_expr .)
    $end            reduce using rule 46 (logic_term -> equality_expr .)
    RPAREN          reduce using rule 46 (logic_term -> equality_expr .)
    LBRACE          reduce using rule 46 (logic_term -> equality_expr .)
    RBRACE          reduce using rule 46 (logic_term -> equality_expr .)
    COMMA           reduce using rule 46 (logic_term -> equality_expr .)
    EQ              shift and go to state 71
    NEQ             shift and go to state 72


state 33

    (66) primary -> atom .

    DOT             reduce using rule 66 (primary -> atom .)
    TIMES           reduce using rule 66 (primary -> atom .)
    DIVIDE          reduce using rule 66 (primary -> atom .)
    MOD             reduce using rule 66 (primary -> atom .)
    PLUS            reduce using rule 66 (primary -> atom .)
    MINUS           reduce using rule 66 (primary -> atom .)
    LT              reduce using rule 66 (primary -> atom .)
    LE              reduce using rule 66 (primary -> atom .)
    GT              reduce using rule 66 (primary -> atom .)
    GE              reduce using rule 66 (primary -> atom .)
    EQ              reduce using rule 66 (primary -> atom .)
    NEQ             reduce using rule 66 (primary -> atom .)
    AND_OP          reduce using rule 66 (primary -> atom .)
    OR_OP           reduce using rule 66 (primary -> atom .)
    INCREMENT       reduce using rule 66 (primary -> atom .)
    DECREMENT       reduce using rule 66 (primary -> atom .)
    NEWLINE         reduce using rule 66 (primary -> atom .)
    $end            reduce using rule 66 (primary -> atom .)
    RPAREN          reduce using rule 66 (primary -> atom .)
    LBRACE          reduce using rule 66 (primary -> atom .)
    RBRACE          reduce using rule 66 (primary -> atom .)
    COMMA           reduce using rule 66 (primary -> atom .)


state 34

    (49) equality_expr -> relational_expr .
    (50) relational_expr -> relational_expr . LT additive_expr
    (51) relational_expr -> relational_expr . LE additive_expr
    (52) relational_expr -> relational_expr . GT additive_expr
    (53) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 49 (equality_expr -> relational_expr .)
    NEQ             reduce using rule 49 (equality_expr -> relational_expr .)
    AND_OP          reduce using rule 49 (equality_expr -> relational_expr .)
    OR_OP           reduce using rule 49 (equality_expr -> relational_expr .)
    INCREMENT       reduce using rule 49 (equality_expr -> relational_expr .)
    DECREMENT       reduce using rule 49 (equality_expr -> relational_expr .)
    NEWLINE         reduce using rule 49 (equality_expr -> relational_expr .)
    $end            reduce using rule 49 (equality_expr -> relational_expr .)
    RPAREN          reduce using rule 49 (equality_expr -> relational_expr .)
    LBRACE          reduce using rule 49 (equality_expr -> relational_expr .)
    RBRACE          reduce using rule 49 (equality_expr -> relational_expr .)
    COMMA           reduce using rule 49 (equality_expr -> relational_expr .)
    LT              shift and go to state 73
    LE              shift and go to state 74
    GT              shift and go to state 75
    GE              shift and go to state 76


state 35

    (69) atom -> NUMBER .

    DOT             reduce using rule 69 (atom -> NUMBER .)
    TIMES           reduce using rule 69 (atom -> NUMBER .)
    DIVIDE          reduce using rule 69 (atom -> NUMBER .)
    MOD             reduce using rule 69 (atom -> NUMBER .)
    PLUS            reduce using rule 69 (atom -> NUMBER .)
    MINUS           reduce using rule 69 (atom -> NUMBER .)
    LT              reduce using rule 69 (atom -> NUMBER .)
    LE              reduce using rule 69 (atom -> NUMBER .)
    GT              reduce using rule 69 (atom -> NUMBER .)
    GE              reduce using rule 69 (atom -> NUMBER .)
    EQ              reduce using rule 69 (atom -> NUMBER .)
    NEQ             reduce using rule 69 (atom -> NUMBER .)
    AND_OP          reduce using rule 69 (atom -> NUMBER .)
    OR_OP           reduce using rule 69 (atom -> NUMBER .)
    INCREMENT       reduce using rule 69 (atom -> NUMBER .)
    DECREMENT       reduce using rule 69 (atom -> NUMBER .)
    NEWLINE         reduce using rule 69 (atom -> NUMBER .)
    $end            reduce using rule 69 (atom -> NUMBER .)
    RPAREN          reduce using rule 69 (atom -> NUMBER .)
    LBRACE          reduce using rule 69 (atom -> NUMBER .)
    RBRACE          reduce using rule 69 (atom -> NUMBER .)
    COMMA           reduce using rule 69 (atom -> NUMBER .)


state 36

    (70) atom -> STRING .

    DOT             reduce using rule 70 (atom -> STRING .)
    TIMES           reduce using rule 70 (atom -> STRING .)
    DIVIDE          reduce using rule 70 (atom -> STRING .)
    MOD             reduce using rule 70 (atom -> STRING .)
    PLUS            reduce using rule 70 (atom -> STRING .)
    MINUS           reduce using rule 70 (atom -> STRING .)
    LT              reduce using rule 70 (atom -> STRING .)
    LE              reduce using rule 70 (atom -> STRING .)
    GT              reduce using rule 70 (atom -> STRING .)
    GE              reduce using rule 70 (atom -> STRING .)
    EQ              reduce using rule 70 (atom -> STRING .)
    NEQ             reduce using rule 70 (atom -> STRING .)
    AND_OP          reduce using rule 70 (atom -> STRING .)
    OR_OP           reduce using rule 70 (atom -> STRING .)
    INCREMENT       reduce using rule 70 (atom -> STRING .)
    DECREMENT       reduce using rule 70 (atom -> STRING .)
    NEWLINE         reduce using rule 70 (atom -> STRING .)
    $end            reduce using rule 70 (atom -> STRING .)
    RPAREN          reduce using rule 70 (atom -> STRING .)
    LBRACE          reduce using rule 70 (atom -> STRING .)
    RBRACE          reduce using rule 70 (atom -> STRING .)
    COMMA           reduce using rule 70 (atom -> STRING .)


state 37

    (71) atom -> TRUE .

    DOT             reduce using rule 71 (atom -> TRUE .)
    TIMES           reduce using rule 71 (atom -> TRUE .)
    DIVIDE          reduce using rule 71 (atom -> TRUE .)
    MOD             reduce using rule 71 (atom -> TRUE .)
    PLUS            reduce using rule 71 (atom -> TRUE .)
    MINUS           reduce using rule 71 (atom -> TRUE .)
    LT              reduce using rule 71 (atom -> TRUE .)
    LE              reduce using rule 71 (atom -> TRUE .)
    GT              reduce using rule 71 (atom -> TRUE .)
    GE              reduce using rule 71 (atom -> TRUE .)
    EQ              reduce using rule 71 (atom -> TRUE .)
    NEQ             reduce using rule 71 (atom -> TRUE .)
    AND_OP          reduce using rule 71 (atom -> TRUE .)
    OR_OP           reduce using rule 71 (atom -> TRUE .)
    INCREMENT       reduce using rule 71 (atom -> TRUE .)
    DECREMENT       reduce using rule 71 (atom -> TRUE .)
    NEWLINE         reduce using rule 71 (atom -> TRUE .)
    $end            reduce using rule 71 (atom -> TRUE .)
    RPAREN          reduce using rule 71 (atom -> TRUE .)
    LBRACE          reduce using rule 71 (atom -> TRUE .)
    RBRACE          reduce using rule 71 (atom -> TRUE .)
    COMMA           reduce using rule 71 (atom -> TRUE .)


state 38

    (72) atom -> FALSE .

    DOT             reduce using rule 72 (atom -> FALSE .)
    TIMES           reduce using rule 72 (atom -> FALSE .)
    DIVIDE          reduce using rule 72 (atom -> FALSE .)
    MOD             reduce using rule 72 (atom -> FALSE .)
    PLUS            reduce using rule 72 (atom -> FALSE .)
    MINUS           reduce using rule 72 (atom -> FALSE .)
    LT              reduce using rule 72 (atom -> FALSE .)
    LE              reduce using rule 72 (atom -> FALSE .)
    GT              reduce using rule 72 (atom -> FALSE .)
    GE              reduce using rule 72 (atom -> FALSE .)
    EQ              reduce using rule 72 (atom -> FALSE .)
    NEQ             reduce using rule 72 (atom -> FALSE .)
    AND_OP          reduce using rule 72 (atom -> FALSE .)
    OR_OP           reduce using rule 72 (atom -> FALSE .)
    INCREMENT       reduce using rule 72 (atom -> FALSE .)
    DECREMENT       reduce using rule 72 (atom -> FALSE .)
    NEWLINE         reduce using rule 72 (atom -> FALSE .)
    $end            reduce using rule 72 (atom -> FALSE .)
    RPAREN          reduce using rule 72 (atom -> FALSE .)
    LBRACE          reduce using rule 72 (atom -> FALSE .)
    RBRACE          reduce using rule 72 (atom -> FALSE .)
    COMMA           reduce using rule 72 (atom -> FALSE .)


state 39

    (54) relational_expr -> additive_expr .
    (55) additive_expr -> additive_expr . PLUS term
    (56) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 54 (relational_expr -> additive_expr .)
    LE              reduce using rule 54 (relational_expr -> additive_expr .)
    GT              reduce using rule 54 (relational_expr -> additive_expr .)
    GE              reduce using rule 54 (relational_expr -> additive_expr .)
    EQ              reduce using rule 54 (relational_expr -> additive_expr .)
    NEQ             reduce using rule 54 (relational_expr -> additive_expr .)
    AND_OP          reduce using rule 54 (relational_expr -> additive_expr .)
    OR_OP           reduce using rule 54 (relational_expr -> additive_expr .)
    INCREMENT       reduce using rule 54 (relational_expr -> additive_expr .)
    DECREMENT       reduce using rule 54 (relational_expr -> additive_expr .)
    NEWLINE         reduce using rule 54 (relational_expr -> additive_expr .)
    $end            reduce using rule 54 (relational_expr -> additive_expr .)
    RPAREN          reduce using rule 54 (relational_expr -> additive_expr .)
    LBRACE          reduce using rule 54 (relational_expr -> additive_expr .)
    RBRACE          reduce using rule 54 (relational_expr -> additive_expr .)
    COMMA           reduce using rule 54 (relational_expr -> additive_expr .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 40

    (62) factor -> PLUS . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    factor                         shift and go to state 79
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 41

    (57) additive_expr -> term .
    (58) term -> term . TIMES factor
    (59) term -> term . DIVIDE factor
    (60) term -> term . MOD factor

    PLUS            reduce using rule 57 (additive_expr -> term .)
    MINUS           reduce using rule 57 (additive_expr -> term .)
    LT              reduce using rule 57 (additive_expr -> term .)
    LE              reduce using rule 57 (additive_expr -> term .)
    GT              reduce using rule 57 (additive_expr -> term .)
    GE              reduce using rule 57 (additive_expr -> term .)
    EQ              reduce using rule 57 (additive_expr -> term .)
    NEQ             reduce using rule 57 (additive_expr -> term .)
    AND_OP          reduce using rule 57 (additive_expr -> term .)
    OR_OP           reduce using rule 57 (additive_expr -> term .)
    INCREMENT       reduce using rule 57 (additive_expr -> term .)
    DECREMENT       reduce using rule 57 (additive_expr -> term .)
    NEWLINE         reduce using rule 57 (additive_expr -> term .)
    $end            reduce using rule 57 (additive_expr -> term .)
    RPAREN          reduce using rule 57 (additive_expr -> term .)
    LBRACE          reduce using rule 57 (additive_expr -> term .)
    RBRACE          reduce using rule 57 (additive_expr -> term .)
    COMMA           reduce using rule 57 (additive_expr -> term .)
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    MOD             shift and go to state 85


state 42

    (63) factor -> MINUS . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    factor                         shift and go to state 86
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 43

    (61) term -> factor .

    TIMES           reduce using rule 61 (term -> factor .)
    DIVIDE          reduce using rule 61 (term -> factor .)
    MOD             reduce using rule 61 (term -> factor .)
    PLUS            reduce using rule 61 (term -> factor .)
    MINUS           reduce using rule 61 (term -> factor .)
    LT              reduce using rule 61 (term -> factor .)
    LE              reduce using rule 61 (term -> factor .)
    GT              reduce using rule 61 (term -> factor .)
    GE              reduce using rule 61 (term -> factor .)
    EQ              reduce using rule 61 (term -> factor .)
    NEQ             reduce using rule 61 (term -> factor .)
    AND_OP          reduce using rule 61 (term -> factor .)
    OR_OP           reduce using rule 61 (term -> factor .)
    INCREMENT       reduce using rule 61 (term -> factor .)
    DECREMENT       reduce using rule 61 (term -> factor .)
    NEWLINE         reduce using rule 61 (term -> factor .)
    $end            reduce using rule 61 (term -> factor .)
    RPAREN          reduce using rule 61 (term -> factor .)
    LBRACE          reduce using rule 61 (term -> factor .)
    RBRACE          reduce using rule 61 (term -> factor .)
    COMMA           reduce using rule 61 (term -> factor .)


state 44

    (64) factor -> NOT . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    factor                         shift and go to state 87
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 45

    (2) program -> statement_list NEWLINE .
    (3) statement_list -> statement_list NEWLINE . statement
    (5) statement -> . assignment
    (6) statement -> . print_statement
    (7) statement -> . if_statement
    (8) statement -> . while_statement
    (9) statement -> . function_def
    (10) statement -> . for_loop
    (11) statement -> . return_statement
    (12) statement -> . wait_statement
    (13) statement -> . block
    (14) statement -> . expression_statement
    (33) statement -> . IMPORT IDENTIFIER
    (20) assignment -> . IDENTIFIER EQUALS expression
    (21) print_statement -> . PRINT LPAREN expression RPAREN
    (22) if_statement -> . IF expression block
    (23) if_statement -> . IF expression block ELSE block
    (27) while_statement -> . WHILE expression block
    (28) function_def -> . DEFINE IDENTIFIER LPAREN RPAREN block
    (29) function_def -> . DEFINE IDENTIFIER LPAREN param_list RPAREN block
    (24) for_loop -> . FOR IDENTIFIER IN iterable block
    (34) return_statement -> . RESULT expression
    (79) wait_statement -> . WAIT expression
    (87) block -> . LBRACE RBRACE
    (88) block -> . LBRACE statement_list RBRACE
    (15) expression_statement -> . expression
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    $end            reduce using rule 2 (program -> statement_list NEWLINE .)
    IMPORT          shift and go to state 14
    IDENTIFIER      shift and go to state 15
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    WHILE           shift and go to state 20
    DEFINE          shift and go to state 21
    FOR             shift and go to state 22
    RESULT          shift and go to state 23
    WAIT            shift and go to state 24
    LBRACE          shift and go to state 25
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    statement                      shift and go to state 88
    assignment                     shift and go to state 4
    print_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    function_def                   shift and go to state 8
    for_loop                       shift and go to state 9
    return_statement               shift and go to state 10
    wait_statement                 shift and go to state 11
    block                          shift and go to state 12
    expression_statement           shift and go to state 13
    expression                     shift and go to state 16
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 46

    (33) statement -> IMPORT IDENTIFIER .

    NEWLINE         reduce using rule 33 (statement -> IMPORT IDENTIFIER .)
    $end            reduce using rule 33 (statement -> IMPORT IDENTIFIER .)
    RBRACE          reduce using rule 33 (statement -> IMPORT IDENTIFIER .)


state 47

    (20) assignment -> IDENTIFIER EQUALS . expression
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 89
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 48

    (18) expression -> IDENTIFIER PLUS_EQUALS . expression
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 90
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 49

    (19) expression -> IDENTIFIER MINUS_EQUALS . expression
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 91
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 50

    (80) function_call -> IDENTIFIER LPAREN . arg_list RPAREN
    (81) function_call -> IDENTIFIER LPAREN . RPAREN
    (84) arg_list -> . expression
    (85) arg_list -> . arg_list COMMA expression
    (86) arg_list -> . empty
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (89) empty -> .
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 93
    IDENTIFIER      shift and go to state 55
    COMMA           reduce using rule 89 (empty -> .)
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

  ! RPAREN          [ reduce using rule 89 (empty -> .) ]

    arg_list                       shift and go to state 92
    expression                     shift and go to state 94
    empty                          shift and go to state 95
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 51

    (16) expression -> expression INCREMENT .

    INCREMENT       reduce using rule 16 (expression -> expression INCREMENT .)
    DECREMENT       reduce using rule 16 (expression -> expression INCREMENT .)
    NEWLINE         reduce using rule 16 (expression -> expression INCREMENT .)
    $end            reduce using rule 16 (expression -> expression INCREMENT .)
    RPAREN          reduce using rule 16 (expression -> expression INCREMENT .)
    LBRACE          reduce using rule 16 (expression -> expression INCREMENT .)
    RBRACE          reduce using rule 16 (expression -> expression INCREMENT .)
    COMMA           reduce using rule 16 (expression -> expression INCREMENT .)


state 52

    (17) expression -> expression DECREMENT .

    INCREMENT       reduce using rule 17 (expression -> expression DECREMENT .)
    DECREMENT       reduce using rule 17 (expression -> expression DECREMENT .)
    NEWLINE         reduce using rule 17 (expression -> expression DECREMENT .)
    $end            reduce using rule 17 (expression -> expression DECREMENT .)
    RPAREN          reduce using rule 17 (expression -> expression DECREMENT .)
    LBRACE          reduce using rule 17 (expression -> expression DECREMENT .)
    RBRACE          reduce using rule 17 (expression -> expression DECREMENT .)
    COMMA           reduce using rule 17 (expression -> expression DECREMENT .)


state 53

    (21) print_statement -> PRINT LPAREN . expression RPAREN
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 96
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 54

    (73) atom -> LPAREN expression . RPAREN
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    RPAREN          shift and go to state 97
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 55

    (18) expression -> IDENTIFIER . PLUS_EQUALS expression
    (19) expression -> IDENTIFIER . MINUS_EQUALS expression
    (80) function_call -> IDENTIFIER . LPAREN arg_list RPAREN
    (81) function_call -> IDENTIFIER . LPAREN RPAREN
    (68) atom -> IDENTIFIER .

    PLUS_EQUALS     shift and go to state 48
    MINUS_EQUALS    shift and go to state 49
    LPAREN          shift and go to state 50
    DOT             reduce using rule 68 (atom -> IDENTIFIER .)
    TIMES           reduce using rule 68 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 68 (atom -> IDENTIFIER .)
    MOD             reduce using rule 68 (atom -> IDENTIFIER .)
    PLUS            reduce using rule 68 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 68 (atom -> IDENTIFIER .)
    LT              reduce using rule 68 (atom -> IDENTIFIER .)
    LE              reduce using rule 68 (atom -> IDENTIFIER .)
    GT              reduce using rule 68 (atom -> IDENTIFIER .)
    GE              reduce using rule 68 (atom -> IDENTIFIER .)
    EQ              reduce using rule 68 (atom -> IDENTIFIER .)
    NEQ             reduce using rule 68 (atom -> IDENTIFIER .)
    AND_OP          reduce using rule 68 (atom -> IDENTIFIER .)
    OR_OP           reduce using rule 68 (atom -> IDENTIFIER .)
    RPAREN          reduce using rule 68 (atom -> IDENTIFIER .)
    INCREMENT       reduce using rule 68 (atom -> IDENTIFIER .)
    DECREMENT       reduce using rule 68 (atom -> IDENTIFIER .)
    LBRACE          reduce using rule 68 (atom -> IDENTIFIER .)
    NEWLINE         reduce using rule 68 (atom -> IDENTIFIER .)
    $end            reduce using rule 68 (atom -> IDENTIFIER .)
    RBRACE          reduce using rule 68 (atom -> IDENTIFIER .)
    COMMA           reduce using rule 68 (atom -> IDENTIFIER .)


state 56

    (22) if_statement -> IF expression . block
    (23) if_statement -> IF expression . block ELSE block
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT
    (87) block -> . LBRACE RBRACE
    (88) block -> . LBRACE statement_list RBRACE

    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    LBRACE          shift and go to state 25

    block                          shift and go to state 98

state 57

    (27) while_statement -> WHILE expression . block
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT
    (87) block -> . LBRACE RBRACE
    (88) block -> . LBRACE statement_list RBRACE

    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52
    LBRACE          shift and go to state 25

    block                          shift and go to state 99

state 58

    (28) function_def -> DEFINE IDENTIFIER . LPAREN RPAREN block
    (29) function_def -> DEFINE IDENTIFIER . LPAREN param_list RPAREN block

    LPAREN          shift and go to state 100


state 59

    (24) for_loop -> FOR IDENTIFIER . IN iterable block

    IN              shift and go to state 101


state 60

    (34) return_statement -> RESULT expression .
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    NEWLINE         reduce using rule 34 (return_statement -> RESULT expression .)
    $end            reduce using rule 34 (return_statement -> RESULT expression .)
    RBRACE          reduce using rule 34 (return_statement -> RESULT expression .)
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 61

    (79) wait_statement -> WAIT expression .
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    NEWLINE         reduce using rule 79 (wait_statement -> WAIT expression .)
    $end            reduce using rule 79 (wait_statement -> WAIT expression .)
    RBRACE          reduce using rule 79 (wait_statement -> WAIT expression .)
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 62

    (87) block -> LBRACE RBRACE .

    NEWLINE         reduce using rule 87 (block -> LBRACE RBRACE .)
    $end            reduce using rule 87 (block -> LBRACE RBRACE .)
    RBRACE          reduce using rule 87 (block -> LBRACE RBRACE .)
    ELSE            reduce using rule 87 (block -> LBRACE RBRACE .)


state 63

    (88) block -> LBRACE statement_list . RBRACE
    (3) statement_list -> statement_list . NEWLINE statement

    RBRACE          shift and go to state 102
    NEWLINE         shift and go to state 103


state 64

    (43) logic_expr -> logic_expr OR_OP . logic_term
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    logic_term                     shift and go to state 104
    equality_expr                  shift and go to state 32
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 65

    (45) logic_term -> logic_term AND_OP . equality_expr
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    equality_expr                  shift and go to state 105
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 66

    (38) fstring -> F_QUOTE fstring_content . QUOTE
    (39) fstring_content -> fstring_content . fstring_part
    (41) fstring_part -> . STRING_CONTENT
    (42) fstring_part -> . LBRACE expression RBRACE

    QUOTE           shift and go to state 106
    STRING_CONTENT  shift and go to state 68
    LBRACE          shift and go to state 69

    fstring_part                   shift and go to state 107

state 67

    (40) fstring_content -> fstring_part .

    QUOTE           reduce using rule 40 (fstring_content -> fstring_part .)
    STRING_CONTENT  reduce using rule 40 (fstring_content -> fstring_part .)
    LBRACE          reduce using rule 40 (fstring_content -> fstring_part .)


state 68

    (41) fstring_part -> STRING_CONTENT .

    QUOTE           reduce using rule 41 (fstring_part -> STRING_CONTENT .)
    STRING_CONTENT  reduce using rule 41 (fstring_part -> STRING_CONTENT .)
    LBRACE          reduce using rule 41 (fstring_part -> STRING_CONTENT .)


state 69

    (42) fstring_part -> LBRACE . expression RBRACE
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 108
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 70

    (82) function_call -> primary DOT . IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> primary DOT . IDENTIFIER LPAREN RPAREN

    IDENTIFIER      shift and go to state 109


state 71

    (47) equality_expr -> equality_expr EQ . relational_expr
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    relational_expr                shift and go to state 110
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 72

    (48) equality_expr -> equality_expr NEQ . relational_expr
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    relational_expr                shift and go to state 111
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 73

    (50) relational_expr -> relational_expr LT . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    additive_expr                  shift and go to state 112
    term                           shift and go to state 41
    factor                         shift and go to state 43
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 74

    (51) relational_expr -> relational_expr LE . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    additive_expr                  shift and go to state 113
    term                           shift and go to state 41
    factor                         shift and go to state 43
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 75

    (52) relational_expr -> relational_expr GT . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    additive_expr                  shift and go to state 114
    term                           shift and go to state 41
    factor                         shift and go to state 43
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 76

    (53) relational_expr -> relational_expr GE . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    additive_expr                  shift and go to state 115
    term                           shift and go to state 41
    factor                         shift and go to state 43
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 77

    (55) additive_expr -> additive_expr PLUS . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    term                           shift and go to state 116
    factor                         shift and go to state 43
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 78

    (56) additive_expr -> additive_expr MINUS . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    term                           shift and go to state 117
    factor                         shift and go to state 43
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 79

    (62) factor -> PLUS factor .

    TIMES           reduce using rule 62 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 62 (factor -> PLUS factor .)
    MOD             reduce using rule 62 (factor -> PLUS factor .)
    PLUS            reduce using rule 62 (factor -> PLUS factor .)
    MINUS           reduce using rule 62 (factor -> PLUS factor .)
    LT              reduce using rule 62 (factor -> PLUS factor .)
    LE              reduce using rule 62 (factor -> PLUS factor .)
    GT              reduce using rule 62 (factor -> PLUS factor .)
    GE              reduce using rule 62 (factor -> PLUS factor .)
    EQ              reduce using rule 62 (factor -> PLUS factor .)
    NEQ             reduce using rule 62 (factor -> PLUS factor .)
    AND_OP          reduce using rule 62 (factor -> PLUS factor .)
    OR_OP           reduce using rule 62 (factor -> PLUS factor .)
    INCREMENT       reduce using rule 62 (factor -> PLUS factor .)
    DECREMENT       reduce using rule 62 (factor -> PLUS factor .)
    NEWLINE         reduce using rule 62 (factor -> PLUS factor .)
    $end            reduce using rule 62 (factor -> PLUS factor .)
    RPAREN          reduce using rule 62 (factor -> PLUS factor .)
    LBRACE          reduce using rule 62 (factor -> PLUS factor .)
    RBRACE          reduce using rule 62 (factor -> PLUS factor .)
    COMMA           reduce using rule 62 (factor -> PLUS factor .)


state 80

    (65) factor -> primary .
    (82) function_call -> primary . DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> primary . DOT IDENTIFIER LPAREN RPAREN

    TIMES           reduce using rule 65 (factor -> primary .)
    DIVIDE          reduce using rule 65 (factor -> primary .)
    MOD             reduce using rule 65 (factor -> primary .)
    PLUS            reduce using rule 65 (factor -> primary .)
    MINUS           reduce using rule 65 (factor -> primary .)
    LT              reduce using rule 65 (factor -> primary .)
    LE              reduce using rule 65 (factor -> primary .)
    GT              reduce using rule 65 (factor -> primary .)
    GE              reduce using rule 65 (factor -> primary .)
    EQ              reduce using rule 65 (factor -> primary .)
    NEQ             reduce using rule 65 (factor -> primary .)
    AND_OP          reduce using rule 65 (factor -> primary .)
    OR_OP           reduce using rule 65 (factor -> primary .)
    INCREMENT       reduce using rule 65 (factor -> primary .)
    DECREMENT       reduce using rule 65 (factor -> primary .)
    NEWLINE         reduce using rule 65 (factor -> primary .)
    $end            reduce using rule 65 (factor -> primary .)
    RPAREN          reduce using rule 65 (factor -> primary .)
    LBRACE          reduce using rule 65 (factor -> primary .)
    RBRACE          reduce using rule 65 (factor -> primary .)
    COMMA           reduce using rule 65 (factor -> primary .)
    DOT             shift and go to state 70


state 81

    (67) primary -> function_call .

    DOT             reduce using rule 67 (primary -> function_call .)
    TIMES           reduce using rule 67 (primary -> function_call .)
    DIVIDE          reduce using rule 67 (primary -> function_call .)
    MOD             reduce using rule 67 (primary -> function_call .)
    PLUS            reduce using rule 67 (primary -> function_call .)
    MINUS           reduce using rule 67 (primary -> function_call .)
    LT              reduce using rule 67 (primary -> function_call .)
    LE              reduce using rule 67 (primary -> function_call .)
    GT              reduce using rule 67 (primary -> function_call .)
    GE              reduce using rule 67 (primary -> function_call .)
    EQ              reduce using rule 67 (primary -> function_call .)
    NEQ             reduce using rule 67 (primary -> function_call .)
    AND_OP          reduce using rule 67 (primary -> function_call .)
    OR_OP           reduce using rule 67 (primary -> function_call .)
    INCREMENT       reduce using rule 67 (primary -> function_call .)
    DECREMENT       reduce using rule 67 (primary -> function_call .)
    NEWLINE         reduce using rule 67 (primary -> function_call .)
    $end            reduce using rule 67 (primary -> function_call .)
    RPAREN          reduce using rule 67 (primary -> function_call .)
    LBRACE          reduce using rule 67 (primary -> function_call .)
    RBRACE          reduce using rule 67 (primary -> function_call .)
    COMMA           reduce using rule 67 (primary -> function_call .)


state 82

    (68) atom -> IDENTIFIER .
    (80) function_call -> IDENTIFIER . LPAREN arg_list RPAREN
    (81) function_call -> IDENTIFIER . LPAREN RPAREN

    DOT             reduce using rule 68 (atom -> IDENTIFIER .)
    TIMES           reduce using rule 68 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 68 (atom -> IDENTIFIER .)
    MOD             reduce using rule 68 (atom -> IDENTIFIER .)
    PLUS            reduce using rule 68 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 68 (atom -> IDENTIFIER .)
    LT              reduce using rule 68 (atom -> IDENTIFIER .)
    LE              reduce using rule 68 (atom -> IDENTIFIER .)
    GT              reduce using rule 68 (atom -> IDENTIFIER .)
    GE              reduce using rule 68 (atom -> IDENTIFIER .)
    EQ              reduce using rule 68 (atom -> IDENTIFIER .)
    NEQ             reduce using rule 68 (atom -> IDENTIFIER .)
    AND_OP          reduce using rule 68 (atom -> IDENTIFIER .)
    OR_OP           reduce using rule 68 (atom -> IDENTIFIER .)
    INCREMENT       reduce using rule 68 (atom -> IDENTIFIER .)
    DECREMENT       reduce using rule 68 (atom -> IDENTIFIER .)
    NEWLINE         reduce using rule 68 (atom -> IDENTIFIER .)
    $end            reduce using rule 68 (atom -> IDENTIFIER .)
    RPAREN          reduce using rule 68 (atom -> IDENTIFIER .)
    LBRACE          reduce using rule 68 (atom -> IDENTIFIER .)
    RBRACE          reduce using rule 68 (atom -> IDENTIFIER .)
    COMMA           reduce using rule 68 (atom -> IDENTIFIER .)
    LPAREN          shift and go to state 50


state 83

    (58) term -> term TIMES . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    factor                         shift and go to state 118
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 84

    (59) term -> term DIVIDE . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    factor                         shift and go to state 119
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 85

    (60) term -> term MOD . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary
    (66) primary -> . atom
    (67) primary -> . function_call
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN

    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44
    IDENTIFIER      shift and go to state 82
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18

    factor                         shift and go to state 120
    primary                        shift and go to state 80
    atom                           shift and go to state 33
    function_call                  shift and go to state 81

state 86

    (63) factor -> MINUS factor .

    TIMES           reduce using rule 63 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 63 (factor -> MINUS factor .)
    MOD             reduce using rule 63 (factor -> MINUS factor .)
    PLUS            reduce using rule 63 (factor -> MINUS factor .)
    MINUS           reduce using rule 63 (factor -> MINUS factor .)
    LT              reduce using rule 63 (factor -> MINUS factor .)
    LE              reduce using rule 63 (factor -> MINUS factor .)
    GT              reduce using rule 63 (factor -> MINUS factor .)
    GE              reduce using rule 63 (factor -> MINUS factor .)
    EQ              reduce using rule 63 (factor -> MINUS factor .)
    NEQ             reduce using rule 63 (factor -> MINUS factor .)
    AND_OP          reduce using rule 63 (factor -> MINUS factor .)
    OR_OP           reduce using rule 63 (factor -> MINUS factor .)
    INCREMENT       reduce using rule 63 (factor -> MINUS factor .)
    DECREMENT       reduce using rule 63 (factor -> MINUS factor .)
    NEWLINE         reduce using rule 63 (factor -> MINUS factor .)
    $end            reduce using rule 63 (factor -> MINUS factor .)
    RPAREN          reduce using rule 63 (factor -> MINUS factor .)
    LBRACE          reduce using rule 63 (factor -> MINUS factor .)
    RBRACE          reduce using rule 63 (factor -> MINUS factor .)
    COMMA           reduce using rule 63 (factor -> MINUS factor .)


state 87

    (64) factor -> NOT factor .

    TIMES           reduce using rule 64 (factor -> NOT factor .)
    DIVIDE          reduce using rule 64 (factor -> NOT factor .)
    MOD             reduce using rule 64 (factor -> NOT factor .)
    PLUS            reduce using rule 64 (factor -> NOT factor .)
    MINUS           reduce using rule 64 (factor -> NOT factor .)
    LT              reduce using rule 64 (factor -> NOT factor .)
    LE              reduce using rule 64 (factor -> NOT factor .)
    GT              reduce using rule 64 (factor -> NOT factor .)
    GE              reduce using rule 64 (factor -> NOT factor .)
    EQ              reduce using rule 64 (factor -> NOT factor .)
    NEQ             reduce using rule 64 (factor -> NOT factor .)
    AND_OP          reduce using rule 64 (factor -> NOT factor .)
    OR_OP           reduce using rule 64 (factor -> NOT factor .)
    INCREMENT       reduce using rule 64 (factor -> NOT factor .)
    DECREMENT       reduce using rule 64 (factor -> NOT factor .)
    NEWLINE         reduce using rule 64 (factor -> NOT factor .)
    $end            reduce using rule 64 (factor -> NOT factor .)
    RPAREN          reduce using rule 64 (factor -> NOT factor .)
    LBRACE          reduce using rule 64 (factor -> NOT factor .)
    RBRACE          reduce using rule 64 (factor -> NOT factor .)
    COMMA           reduce using rule 64 (factor -> NOT factor .)


state 88

    (3) statement_list -> statement_list NEWLINE statement .

    NEWLINE         reduce using rule 3 (statement_list -> statement_list NEWLINE statement .)
    $end            reduce using rule 3 (statement_list -> statement_list NEWLINE statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement_list NEWLINE statement .)


state 89

    (20) assignment -> IDENTIFIER EQUALS expression .
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    NEWLINE         reduce using rule 20 (assignment -> IDENTIFIER EQUALS expression .)
    $end            reduce using rule 20 (assignment -> IDENTIFIER EQUALS expression .)
    RBRACE          reduce using rule 20 (assignment -> IDENTIFIER EQUALS expression .)
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 90

    (18) expression -> IDENTIFIER PLUS_EQUALS expression .
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
    NEWLINE         reduce using rule 18 (expression -> IDENTIFIER PLUS_EQUALS expression .)
    $end            reduce using rule 18 (expression -> IDENTIFIER PLUS_EQUALS expression .)
    RPAREN          reduce using rule 18 (expression -> IDENTIFIER PLUS_EQUALS expression .)
    LBRACE          reduce using rule 18 (expression -> IDENTIFIER PLUS_EQUALS expression .)
    RBRACE          reduce using rule 18 (expression -> IDENTIFIER PLUS_EQUALS expression .)
    COMMA           reduce using rule 18 (expression -> IDENTIFIER PLUS_EQUALS expression .)
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52

  ! INCREMENT       [ reduce using rule 18 (expression -> IDENTIFIER PLUS_EQUALS expression .) ]
  ! DECREMENT       [ reduce using rule 18 (expression -> IDENTIFIER PLUS_EQUALS expression .) ]


state 91

    (19) expression -> IDENTIFIER MINUS_EQUALS expression .
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
    NEWLINE         reduce using rule 19 (expression -> IDENTIFIER MINUS_EQUALS expression .)
    $end            reduce using rule 19 (expression -> IDENTIFIER MINUS_EQUALS expression .)
    RPAREN          reduce using rule 19 (expression -> IDENTIFIER MINUS_EQUALS expression .)
    LBRACE          reduce using rule 19 (expression -> IDENTIFIER MINUS_EQUALS expression .)
    RBRACE          reduce using rule 19 (expression -> IDENTIFIER MINUS_EQUALS expression .)
    COMMA           reduce using rule 19 (expression -> IDENTIFIER MINUS_EQUALS expression .)
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52

  ! INCREMENT       [ reduce using rule 19 (expression -> IDENTIFIER MINUS_EQUALS expression .) ]
  ! DECREMENT       [ reduce using rule 19 (expression -> IDENTIFIER MINUS_EQUALS expression .) ]


state 92

    (80) function_call -> IDENTIFIER LPAREN arg_list . RPAREN
    (85) arg_list -> arg_list . COMMA expression

    RPAREN          shift and go to state 121
    COMMA           shift and go to state 122


state 93

    (81) function_call -> IDENTIFIER LPAREN RPAREN .

    INCREMENT       reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DECREMENT       reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    NEWLINE         reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MOD             reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LT              reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LE              reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    GT              reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    GE              reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    EQ              reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    NEQ             reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    AND_OP          reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    OR_OP           reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LBRACE          reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 81 (function_call -> IDENTIFIER LPAREN RPAREN .)


state 94

    (84) arg_list -> expression .
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    RPAREN          reduce using rule 84 (arg_list -> expression .)
    COMMA           reduce using rule 84 (arg_list -> expression .)
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 95

    (86) arg_list -> empty .

    RPAREN          reduce using rule 86 (arg_list -> empty .)
    COMMA           reduce using rule 86 (arg_list -> empty .)


state 96

    (21) print_statement -> PRINT LPAREN expression . RPAREN
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    RPAREN          shift and go to state 123
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 97

    (73) atom -> LPAREN expression RPAREN .

    DOT             reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    MOD             reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    LT              reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    LE              reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    GT              reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    GE              reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    EQ              reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    AND_OP          reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    OR_OP           reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    INCREMENT       reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    DECREMENT       reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    $end            reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 73 (atom -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 73 (atom -> LPAREN expression RPAREN .)


state 98

    (22) if_statement -> IF expression block .
    (23) if_statement -> IF expression block . ELSE block

    NEWLINE         reduce using rule 22 (if_statement -> IF expression block .)
    $end            reduce using rule 22 (if_statement -> IF expression block .)
    RBRACE          reduce using rule 22 (if_statement -> IF expression block .)
    ELSE            shift and go to state 124


state 99

    (27) while_statement -> WHILE expression block .

    NEWLINE         reduce using rule 27 (while_statement -> WHILE expression block .)
    $end            reduce using rule 27 (while_statement -> WHILE expression block .)
    RBRACE          reduce using rule 27 (while_statement -> WHILE expression block .)


state 100

    (28) function_def -> DEFINE IDENTIFIER LPAREN . RPAREN block
    (29) function_def -> DEFINE IDENTIFIER LPAREN . param_list RPAREN block
    (30) param_list -> . IDENTIFIER
    (31) param_list -> . param_list COMMA IDENTIFIER
    (32) param_list -> . empty
    (89) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 126
    IDENTIFIER      shift and go to state 125
    COMMA           reduce using rule 89 (empty -> .)

  ! RPAREN          [ reduce using rule 89 (empty -> .) ]

    param_list                     shift and go to state 127
    empty                          shift and go to state 128

state 101

    (24) for_loop -> FOR IDENTIFIER IN . iterable block
    (25) iterable -> . expression
    (26) iterable -> . RANGE LPAREN expression COMMA expression RPAREN
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    RANGE           shift and go to state 131
    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    iterable                       shift and go to state 129
    expression                     shift and go to state 130
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 102

    (88) block -> LBRACE statement_list RBRACE .

    NEWLINE         reduce using rule 88 (block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 88 (block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 88 (block -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 88 (block -> LBRACE statement_list RBRACE .)


state 103

    (3) statement_list -> statement_list NEWLINE . statement
    (5) statement -> . assignment
    (6) statement -> . print_statement
    (7) statement -> . if_statement
    (8) statement -> . while_statement
    (9) statement -> . function_def
    (10) statement -> . for_loop
    (11) statement -> . return_statement
    (12) statement -> . wait_statement
    (13) statement -> . block
    (14) statement -> . expression_statement
    (33) statement -> . IMPORT IDENTIFIER
    (20) assignment -> . IDENTIFIER EQUALS expression
    (21) print_statement -> . PRINT LPAREN expression RPAREN
    (22) if_statement -> . IF expression block
    (23) if_statement -> . IF expression block ELSE block
    (27) while_statement -> . WHILE expression block
    (28) function_def -> . DEFINE IDENTIFIER LPAREN RPAREN block
    (29) function_def -> . DEFINE IDENTIFIER LPAREN param_list RPAREN block
    (24) for_loop -> . FOR IDENTIFIER IN iterable block
    (34) return_statement -> . RESULT expression
    (79) wait_statement -> . WAIT expression
    (87) block -> . LBRACE RBRACE
    (88) block -> . LBRACE statement_list RBRACE
    (15) expression_statement -> . expression
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IMPORT          shift and go to state 14
    IDENTIFIER      shift and go to state 15
    PRINT           shift and go to state 17
    IF              shift and go to state 19
    WHILE           shift and go to state 20
    DEFINE          shift and go to state 21
    FOR             shift and go to state 22
    RESULT          shift and go to state 23
    WAIT            shift and go to state 24
    LBRACE          shift and go to state 25
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    statement                      shift and go to state 88
    assignment                     shift and go to state 4
    print_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    while_statement                shift and go to state 7
    function_def                   shift and go to state 8
    for_loop                       shift and go to state 9
    return_statement               shift and go to state 10
    wait_statement                 shift and go to state 11
    block                          shift and go to state 12
    expression_statement           shift and go to state 13
    expression                     shift and go to state 16
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 104

    (43) logic_expr -> logic_expr OR_OP logic_term .
    (45) logic_term -> logic_term . AND_OP equality_expr

    OR_OP           reduce using rule 43 (logic_expr -> logic_expr OR_OP logic_term .)
    INCREMENT       reduce using rule 43 (logic_expr -> logic_expr OR_OP logic_term .)
    DECREMENT       reduce using rule 43 (logic_expr -> logic_expr OR_OP logic_term .)
    NEWLINE         reduce using rule 43 (logic_expr -> logic_expr OR_OP logic_term .)
    $end            reduce using rule 43 (logic_expr -> logic_expr OR_OP logic_term .)
    RPAREN          reduce using rule 43 (logic_expr -> logic_expr OR_OP logic_term .)
    LBRACE          reduce using rule 43 (logic_expr -> logic_expr OR_OP logic_term .)
    RBRACE          reduce using rule 43 (logic_expr -> logic_expr OR_OP logic_term .)
    COMMA           reduce using rule 43 (logic_expr -> logic_expr OR_OP logic_term .)
    AND_OP          shift and go to state 65


state 105

    (45) logic_term -> logic_term AND_OP equality_expr .
    (47) equality_expr -> equality_expr . EQ relational_expr
    (48) equality_expr -> equality_expr . NEQ relational_expr

    AND_OP          reduce using rule 45 (logic_term -> logic_term AND_OP equality_expr .)
    OR_OP           reduce using rule 45 (logic_term -> logic_term AND_OP equality_expr .)
    INCREMENT       reduce using rule 45 (logic_term -> logic_term AND_OP equality_expr .)
    DECREMENT       reduce using rule 45 (logic_term -> logic_term AND_OP equality_expr .)
    NEWLINE         reduce using rule 45 (logic_term -> logic_term AND_OP equality_expr .)
    $end            reduce using rule 45 (logic_term -> logic_term AND_OP equality_expr .)
    RPAREN          reduce using rule 45 (logic_term -> logic_term AND_OP equality_expr .)
    LBRACE          reduce using rule 45 (logic_term -> logic_term AND_OP equality_expr .)
    RBRACE          reduce using rule 45 (logic_term -> logic_term AND_OP equality_expr .)
    COMMA           reduce using rule 45 (logic_term -> logic_term AND_OP equality_expr .)
    EQ              shift and go to state 71
    NEQ             shift and go to state 72


state 106

    (38) fstring -> F_QUOTE fstring_content QUOTE .

    INCREMENT       reduce using rule 38 (fstring -> F_QUOTE fstring_content QUOTE .)
    DECREMENT       reduce using rule 38 (fstring -> F_QUOTE fstring_content QUOTE .)
    NEWLINE         reduce using rule 38 (fstring -> F_QUOTE fstring_content QUOTE .)
    $end            reduce using rule 38 (fstring -> F_QUOTE fstring_content QUOTE .)
    RPAREN          reduce using rule 38 (fstring -> F_QUOTE fstring_content QUOTE .)
    LBRACE          reduce using rule 38 (fstring -> F_QUOTE fstring_content QUOTE .)
    RBRACE          reduce using rule 38 (fstring -> F_QUOTE fstring_content QUOTE .)
    COMMA           reduce using rule 38 (fstring -> F_QUOTE fstring_content QUOTE .)


state 107

    (39) fstring_content -> fstring_content fstring_part .

    QUOTE           reduce using rule 39 (fstring_content -> fstring_content fstring_part .)
    STRING_CONTENT  reduce using rule 39 (fstring_content -> fstring_content fstring_part .)
    LBRACE          reduce using rule 39 (fstring_content -> fstring_content fstring_part .)


state 108

    (42) fstring_part -> LBRACE expression . RBRACE
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    RBRACE          shift and go to state 132
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 109

    (82) function_call -> primary DOT IDENTIFIER . LPAREN arg_list RPAREN
    (83) function_call -> primary DOT IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 133


state 110

    (47) equality_expr -> equality_expr EQ relational_expr .
    (50) relational_expr -> relational_expr . LT additive_expr
    (51) relational_expr -> relational_expr . LE additive_expr
    (52) relational_expr -> relational_expr . GT additive_expr
    (53) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    NEQ             reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    AND_OP          reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    OR_OP           reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    INCREMENT       reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    DECREMENT       reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    NEWLINE         reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    $end            reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    RPAREN          reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    LBRACE          reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    RBRACE          reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    COMMA           reduce using rule 47 (equality_expr -> equality_expr EQ relational_expr .)
    LT              shift and go to state 73
    LE              shift and go to state 74
    GT              shift and go to state 75
    GE              shift and go to state 76


state 111

    (48) equality_expr -> equality_expr NEQ relational_expr .
    (50) relational_expr -> relational_expr . LT additive_expr
    (51) relational_expr -> relational_expr . LE additive_expr
    (52) relational_expr -> relational_expr . GT additive_expr
    (53) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    NEQ             reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    AND_OP          reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    OR_OP           reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    INCREMENT       reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    DECREMENT       reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    NEWLINE         reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    $end            reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    RPAREN          reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    LBRACE          reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    RBRACE          reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    COMMA           reduce using rule 48 (equality_expr -> equality_expr NEQ relational_expr .)
    LT              shift and go to state 73
    LE              shift and go to state 74
    GT              shift and go to state 75
    GE              shift and go to state 76


state 112

    (50) relational_expr -> relational_expr LT additive_expr .
    (55) additive_expr -> additive_expr . PLUS term
    (56) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    LE              reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    GT              reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    GE              reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    EQ              reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    NEQ             reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    AND_OP          reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    OR_OP           reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    INCREMENT       reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    DECREMENT       reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    NEWLINE         reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    $end            reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    RPAREN          reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    LBRACE          reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    RBRACE          reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    COMMA           reduce using rule 50 (relational_expr -> relational_expr LT additive_expr .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 113

    (51) relational_expr -> relational_expr LE additive_expr .
    (55) additive_expr -> additive_expr . PLUS term
    (56) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    LE              reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    GT              reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    GE              reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    EQ              reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    NEQ             reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    AND_OP          reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    OR_OP           reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    INCREMENT       reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    DECREMENT       reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    NEWLINE         reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    $end            reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    RPAREN          reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    LBRACE          reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    RBRACE          reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    COMMA           reduce using rule 51 (relational_expr -> relational_expr LE additive_expr .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 114

    (52) relational_expr -> relational_expr GT additive_expr .
    (55) additive_expr -> additive_expr . PLUS term
    (56) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    LE              reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    GT              reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    GE              reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    EQ              reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    NEQ             reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    AND_OP          reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    OR_OP           reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    INCREMENT       reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    DECREMENT       reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    NEWLINE         reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    $end            reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    RPAREN          reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    LBRACE          reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    RBRACE          reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    COMMA           reduce using rule 52 (relational_expr -> relational_expr GT additive_expr .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 115

    (53) relational_expr -> relational_expr GE additive_expr .
    (55) additive_expr -> additive_expr . PLUS term
    (56) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    LE              reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    GT              reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    GE              reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    EQ              reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    NEQ             reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    AND_OP          reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    OR_OP           reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    INCREMENT       reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    DECREMENT       reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    NEWLINE         reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    $end            reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    RPAREN          reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    LBRACE          reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    RBRACE          reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    COMMA           reduce using rule 53 (relational_expr -> relational_expr GE additive_expr .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 116

    (55) additive_expr -> additive_expr PLUS term .
    (58) term -> term . TIMES factor
    (59) term -> term . DIVIDE factor
    (60) term -> term . MOD factor

    PLUS            reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    MINUS           reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    LT              reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    LE              reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    GT              reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    GE              reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    EQ              reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    NEQ             reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    AND_OP          reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    OR_OP           reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    INCREMENT       reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    DECREMENT       reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    NEWLINE         reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    $end            reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    RPAREN          reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    LBRACE          reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    RBRACE          reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    COMMA           reduce using rule 55 (additive_expr -> additive_expr PLUS term .)
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    MOD             shift and go to state 85


state 117

    (56) additive_expr -> additive_expr MINUS term .
    (58) term -> term . TIMES factor
    (59) term -> term . DIVIDE factor
    (60) term -> term . MOD factor

    PLUS            reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    MINUS           reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    LT              reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    LE              reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    GT              reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    GE              reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    EQ              reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    NEQ             reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    AND_OP          reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    OR_OP           reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    INCREMENT       reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    DECREMENT       reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    NEWLINE         reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    $end            reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    RPAREN          reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    LBRACE          reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    RBRACE          reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    COMMA           reduce using rule 56 (additive_expr -> additive_expr MINUS term .)
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    MOD             shift and go to state 85


state 118

    (58) term -> term TIMES factor .

    TIMES           reduce using rule 58 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 58 (term -> term TIMES factor .)
    MOD             reduce using rule 58 (term -> term TIMES factor .)
    PLUS            reduce using rule 58 (term -> term TIMES factor .)
    MINUS           reduce using rule 58 (term -> term TIMES factor .)
    LT              reduce using rule 58 (term -> term TIMES factor .)
    LE              reduce using rule 58 (term -> term TIMES factor .)
    GT              reduce using rule 58 (term -> term TIMES factor .)
    GE              reduce using rule 58 (term -> term TIMES factor .)
    EQ              reduce using rule 58 (term -> term TIMES factor .)
    NEQ             reduce using rule 58 (term -> term TIMES factor .)
    AND_OP          reduce using rule 58 (term -> term TIMES factor .)
    OR_OP           reduce using rule 58 (term -> term TIMES factor .)
    INCREMENT       reduce using rule 58 (term -> term TIMES factor .)
    DECREMENT       reduce using rule 58 (term -> term TIMES factor .)
    NEWLINE         reduce using rule 58 (term -> term TIMES factor .)
    $end            reduce using rule 58 (term -> term TIMES factor .)
    RPAREN          reduce using rule 58 (term -> term TIMES factor .)
    LBRACE          reduce using rule 58 (term -> term TIMES factor .)
    RBRACE          reduce using rule 58 (term -> term TIMES factor .)
    COMMA           reduce using rule 58 (term -> term TIMES factor .)


state 119

    (59) term -> term DIVIDE factor .

    TIMES           reduce using rule 59 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 59 (term -> term DIVIDE factor .)
    MOD             reduce using rule 59 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 59 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 59 (term -> term DIVIDE factor .)
    LT              reduce using rule 59 (term -> term DIVIDE factor .)
    LE              reduce using rule 59 (term -> term DIVIDE factor .)
    GT              reduce using rule 59 (term -> term DIVIDE factor .)
    GE              reduce using rule 59 (term -> term DIVIDE factor .)
    EQ              reduce using rule 59 (term -> term DIVIDE factor .)
    NEQ             reduce using rule 59 (term -> term DIVIDE factor .)
    AND_OP          reduce using rule 59 (term -> term DIVIDE factor .)
    OR_OP           reduce using rule 59 (term -> term DIVIDE factor .)
    INCREMENT       reduce using rule 59 (term -> term DIVIDE factor .)
    DECREMENT       reduce using rule 59 (term -> term DIVIDE factor .)
    NEWLINE         reduce using rule 59 (term -> term DIVIDE factor .)
    $end            reduce using rule 59 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 59 (term -> term DIVIDE factor .)
    LBRACE          reduce using rule 59 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 59 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 59 (term -> term DIVIDE factor .)


state 120

    (60) term -> term MOD factor .

    TIMES           reduce using rule 60 (term -> term MOD factor .)
    DIVIDE          reduce using rule 60 (term -> term MOD factor .)
    MOD             reduce using rule 60 (term -> term MOD factor .)
    PLUS            reduce using rule 60 (term -> term MOD factor .)
    MINUS           reduce using rule 60 (term -> term MOD factor .)
    LT              reduce using rule 60 (term -> term MOD factor .)
    LE              reduce using rule 60 (term -> term MOD factor .)
    GT              reduce using rule 60 (term -> term MOD factor .)
    GE              reduce using rule 60 (term -> term MOD factor .)
    EQ              reduce using rule 60 (term -> term MOD factor .)
    NEQ             reduce using rule 60 (term -> term MOD factor .)
    AND_OP          reduce using rule 60 (term -> term MOD factor .)
    OR_OP           reduce using rule 60 (term -> term MOD factor .)
    INCREMENT       reduce using rule 60 (term -> term MOD factor .)
    DECREMENT       reduce using rule 60 (term -> term MOD factor .)
    NEWLINE         reduce using rule 60 (term -> term MOD factor .)
    $end            reduce using rule 60 (term -> term MOD factor .)
    RPAREN          reduce using rule 60 (term -> term MOD factor .)
    LBRACE          reduce using rule 60 (term -> term MOD factor .)
    RBRACE          reduce using rule 60 (term -> term MOD factor .)
    COMMA           reduce using rule 60 (term -> term MOD factor .)


state 121

    (80) function_call -> IDENTIFIER LPAREN arg_list RPAREN .

    INCREMENT       reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DECREMENT       reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    NEWLINE         reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    $end            reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DOT             reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    TIMES           reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    DIVIDE          reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    MOD             reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    LT              reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    LE              reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    GT              reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    GE              reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    EQ              reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    NEQ             reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    AND_OP          reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    OR_OP           reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    LBRACE          reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    RBRACE          reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 80 (function_call -> IDENTIFIER LPAREN arg_list RPAREN .)


state 122

    (85) arg_list -> arg_list COMMA . expression
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 134
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 123

    (21) print_statement -> PRINT LPAREN expression RPAREN .

    NEWLINE         reduce using rule 21 (print_statement -> PRINT LPAREN expression RPAREN .)
    $end            reduce using rule 21 (print_statement -> PRINT LPAREN expression RPAREN .)
    RBRACE          reduce using rule 21 (print_statement -> PRINT LPAREN expression RPAREN .)


state 124

    (23) if_statement -> IF expression block ELSE . block
    (87) block -> . LBRACE RBRACE
    (88) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 25

    block                          shift and go to state 135

state 125

    (30) param_list -> IDENTIFIER .

    RPAREN          reduce using rule 30 (param_list -> IDENTIFIER .)
    COMMA           reduce using rule 30 (param_list -> IDENTIFIER .)


state 126

    (28) function_def -> DEFINE IDENTIFIER LPAREN RPAREN . block
    (87) block -> . LBRACE RBRACE
    (88) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 25

    block                          shift and go to state 136

state 127

    (29) function_def -> DEFINE IDENTIFIER LPAREN param_list . RPAREN block
    (31) param_list -> param_list . COMMA IDENTIFIER

    RPAREN          shift and go to state 137
    COMMA           shift and go to state 138


state 128

    (32) param_list -> empty .

    RPAREN          reduce using rule 32 (param_list -> empty .)
    COMMA           reduce using rule 32 (param_list -> empty .)


state 129

    (24) for_loop -> FOR IDENTIFIER IN iterable . block
    (87) block -> . LBRACE RBRACE
    (88) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 25

    block                          shift and go to state 139

state 130

    (25) iterable -> expression .
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    LBRACE          reduce using rule 25 (iterable -> expression .)
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 131

    (26) iterable -> RANGE . LPAREN expression COMMA expression RPAREN

    LPAREN          shift and go to state 140


state 132

    (42) fstring_part -> LBRACE expression RBRACE .

    QUOTE           reduce using rule 42 (fstring_part -> LBRACE expression RBRACE .)
    STRING_CONTENT  reduce using rule 42 (fstring_part -> LBRACE expression RBRACE .)
    LBRACE          reduce using rule 42 (fstring_part -> LBRACE expression RBRACE .)


state 133

    (82) function_call -> primary DOT IDENTIFIER LPAREN . arg_list RPAREN
    (83) function_call -> primary DOT IDENTIFIER LPAREN . RPAREN
    (84) arg_list -> . expression
    (85) arg_list -> . arg_list COMMA expression
    (86) arg_list -> . empty
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (89) empty -> .
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 142
    IDENTIFIER      shift and go to state 55
    COMMA           reduce using rule 89 (empty -> .)
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

  ! RPAREN          [ reduce using rule 89 (empty -> .) ]

    primary                        shift and go to state 31
    arg_list                       shift and go to state 141
    expression                     shift and go to state 94
    empty                          shift and go to state 95
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 134

    (85) arg_list -> arg_list COMMA expression .
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    RPAREN          reduce using rule 85 (arg_list -> arg_list COMMA expression .)
    COMMA           reduce using rule 85 (arg_list -> arg_list COMMA expression .)
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 135

    (23) if_statement -> IF expression block ELSE block .

    NEWLINE         reduce using rule 23 (if_statement -> IF expression block ELSE block .)
    $end            reduce using rule 23 (if_statement -> IF expression block ELSE block .)
    RBRACE          reduce using rule 23 (if_statement -> IF expression block ELSE block .)


state 136

    (28) function_def -> DEFINE IDENTIFIER LPAREN RPAREN block .

    NEWLINE         reduce using rule 28 (function_def -> DEFINE IDENTIFIER LPAREN RPAREN block .)
    $end            reduce using rule 28 (function_def -> DEFINE IDENTIFIER LPAREN RPAREN block .)
    RBRACE          reduce using rule 28 (function_def -> DEFINE IDENTIFIER LPAREN RPAREN block .)


state 137

    (29) function_def -> DEFINE IDENTIFIER LPAREN param_list RPAREN . block
    (87) block -> . LBRACE RBRACE
    (88) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 25

    block                          shift and go to state 143

state 138

    (31) param_list -> param_list COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 144


state 139

    (24) for_loop -> FOR IDENTIFIER IN iterable block .

    NEWLINE         reduce using rule 24 (for_loop -> FOR IDENTIFIER IN iterable block .)
    $end            reduce using rule 24 (for_loop -> FOR IDENTIFIER IN iterable block .)
    RBRACE          reduce using rule 24 (for_loop -> FOR IDENTIFIER IN iterable block .)


state 140

    (26) iterable -> RANGE LPAREN . expression COMMA expression RPAREN
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 145
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 141

    (82) function_call -> primary DOT IDENTIFIER LPAREN arg_list . RPAREN
    (85) arg_list -> arg_list . COMMA expression

    RPAREN          shift and go to state 146
    COMMA           shift and go to state 122


state 142

    (83) function_call -> primary DOT IDENTIFIER LPAREN RPAREN .

    INCREMENT       reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    DECREMENT       reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    NEWLINE         reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    MOD             reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    LT              reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    LE              reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    GT              reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    GE              reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    EQ              reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    NEQ             reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    AND_OP          reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    OR_OP           reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    LBRACE          reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 83 (function_call -> primary DOT IDENTIFIER LPAREN RPAREN .)


state 143

    (29) function_def -> DEFINE IDENTIFIER LPAREN param_list RPAREN block .

    NEWLINE         reduce using rule 29 (function_def -> DEFINE IDENTIFIER LPAREN param_list RPAREN block .)
    $end            reduce using rule 29 (function_def -> DEFINE IDENTIFIER LPAREN param_list RPAREN block .)
    RBRACE          reduce using rule 29 (function_def -> DEFINE IDENTIFIER LPAREN param_list RPAREN block .)


state 144

    (31) param_list -> param_list COMMA IDENTIFIER .

    RPAREN          reduce using rule 31 (param_list -> param_list COMMA IDENTIFIER .)
    COMMA           reduce using rule 31 (param_list -> param_list COMMA IDENTIFIER .)


state 145

    (26) iterable -> RANGE LPAREN expression . COMMA expression RPAREN
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    COMMA           shift and go to state 147
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 146

    (82) function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .

    INCREMENT       reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    DECREMENT       reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    NEWLINE         reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    $end            reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    DOT             reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    TIMES           reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    DIVIDE          reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    MOD             reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    LT              reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    LE              reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    GT              reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    GE              reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    EQ              reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    NEQ             reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    AND_OP          reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    OR_OP           reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    LBRACE          reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    RBRACE          reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 82 (function_call -> primary DOT IDENTIFIER LPAREN arg_list RPAREN .)


state 147

    (26) iterable -> RANGE LPAREN expression COMMA . expression RPAREN
    (16) expression -> . expression INCREMENT
    (17) expression -> . expression DECREMENT
    (18) expression -> . IDENTIFIER PLUS_EQUALS expression
    (19) expression -> . IDENTIFIER MINUS_EQUALS expression
    (35) expression -> . logic_expr
    (36) expression -> . fstring
    (37) expression -> . function_call
    (43) logic_expr -> . logic_expr OR_OP logic_term
    (44) logic_expr -> . logic_term
    (38) fstring -> . F_QUOTE fstring_content QUOTE
    (80) function_call -> . IDENTIFIER LPAREN arg_list RPAREN
    (81) function_call -> . IDENTIFIER LPAREN RPAREN
    (82) function_call -> . primary DOT IDENTIFIER LPAREN arg_list RPAREN
    (83) function_call -> . primary DOT IDENTIFIER LPAREN RPAREN
    (45) logic_term -> . logic_term AND_OP equality_expr
    (46) logic_term -> . equality_expr
    (66) primary -> . atom
    (67) primary -> . function_call
    (47) equality_expr -> . equality_expr EQ relational_expr
    (48) equality_expr -> . equality_expr NEQ relational_expr
    (49) equality_expr -> . relational_expr
    (68) atom -> . IDENTIFIER
    (69) atom -> . NUMBER
    (70) atom -> . STRING
    (71) atom -> . TRUE
    (72) atom -> . FALSE
    (73) atom -> . LPAREN expression RPAREN
    (50) relational_expr -> . relational_expr LT additive_expr
    (51) relational_expr -> . relational_expr LE additive_expr
    (52) relational_expr -> . relational_expr GT additive_expr
    (53) relational_expr -> . relational_expr GE additive_expr
    (54) relational_expr -> . additive_expr
    (55) additive_expr -> . additive_expr PLUS term
    (56) additive_expr -> . additive_expr MINUS term
    (57) additive_expr -> . term
    (58) term -> . term TIMES factor
    (59) term -> . term DIVIDE factor
    (60) term -> . term MOD factor
    (61) term -> . factor
    (62) factor -> . PLUS factor
    (63) factor -> . MINUS factor
    (64) factor -> . NOT factor
    (65) factor -> . primary

    IDENTIFIER      shift and go to state 55
    F_QUOTE         shift and go to state 30
    NUMBER          shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38
    LPAREN          shift and go to state 18
    PLUS            shift and go to state 40
    MINUS           shift and go to state 42
    NOT             shift and go to state 44

    expression                     shift and go to state 148
    logic_expr                     shift and go to state 26
    fstring                        shift and go to state 27
    function_call                  shift and go to state 28
    logic_term                     shift and go to state 29
    primary                        shift and go to state 31
    equality_expr                  shift and go to state 32
    atom                           shift and go to state 33
    relational_expr                shift and go to state 34
    additive_expr                  shift and go to state 39
    term                           shift and go to state 41
    factor                         shift and go to state 43

state 148

    (26) iterable -> RANGE LPAREN expression COMMA expression . RPAREN
    (16) expression -> expression . INCREMENT
    (17) expression -> expression . DECREMENT

    RPAREN          shift and go to state 149
    INCREMENT       shift and go to state 51
    DECREMENT       shift and go to state 52


state 149

    (26) iterable -> RANGE LPAREN expression COMMA expression RPAREN .

    LBRACE          reduce using rule 26 (iterable -> RANGE LPAREN expression COMMA expression RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 50 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 90 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 90 resolved as shift
WARNING: shift/reduce conflict for INCREMENT in state 91 resolved as shift
WARNING: shift/reduce conflict for DECREMENT in state 91 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 100 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 133 resolved as shift
WARNING: reduce/reduce conflict in state 28 resolved using rule (expression -> function_call)
WARNING: rejected rule (primary -> function_call) in state 28
